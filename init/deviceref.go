package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"runtime"
	"strconv"
	"strings"

	"github.com/foxboron/go-uefi/efi/attributes"
	"github.com/foxboron/go-uefi/efi/util"
)

type refFormat uint8

const (
	refName           refFormat = iota // name of the block device, e.g. "sda". It corresponds to path inside /dev/ directory.
	refEspUUID                         // uuid of the EFI System Partition (for root autodetect)
	refGptUUID                         // uuid of the gpt partition
	refGptUUIDPartoff                  // offset against a gpt partition with uuid
	refGptLabel
	refFsUUID
	refFsLabel
)

// The are many ways a user can specify root partition (using name, fs uuid, fs label, gpt attribute, ...).
// This struct abstracts this information and provides a convenient matching functions.
type deviceRef struct {
	format refFormat
	data   interface{}
}

type gptPartoffData struct {
	uuid   UUID
	offset int
}

func (d *deviceRef) matchesBlkInfo(info *blkInfo) bool {
	switch d.format {
	case refName:
		return d.data.(string) == info.path
	case refFsUUID:
		return bytes.Equal(d.data.(UUID), info.uuid)
	case refFsLabel:
		return d.data.(string) == info.label
	default:
		return false
	}
}

func calculateDevName(parent string, partition int) string {
	name := parent
	// some drivers use 'p' prefix for the partition number. TODO: find out where it is codified.
	if strings.HasPrefix(parent, "/dev/nvme") || strings.HasPrefix(parent, "/dev/mmcblk") {
		name += "p"
	}
	name += strconv.Itoa(partition + 1) // devname partitions start with "1"
	return name
}

// checks if the reference is a gpt-specific and if yes then tries to resolve it to a device name
func (d *deviceRef) resolveFromGptTable(devPath string, t []gptPart) *deviceRef {
	if d.format != refEspUUID && d.format != refGptUUID && d.format != refGptLabel && d.format != refGptUUIDPartoff {
		return d
	}

	for _, p := range t {
		switch d.format {
		case refEspUUID:
			if bytes.Equal(d.data.(UUID), p.uuid) {
				return d.autodetectRoot(devPath, t)
			}
		case refGptUUID:
			if bytes.Equal(d.data.(UUID), p.uuid) {
				return &deviceRef{refName, calculateDevName(devPath, p.num)}
			}
		case refGptUUIDPartoff:
			data := d.data.(gptPartoffData)
			if bytes.Equal(data.uuid, p.uuid) {
				return &deviceRef{refName, calculateDevName(devPath, p.num+data.offset)}
			}
		case refGptLabel:
			if d.data.(string) == p.name {
				return &deviceRef{refName, calculateDevName(devPath, p.num)}
			}
		}
	}

	return d
}

var autodiscoveryRootGptTypes = map[string]string{
	"amd64": "4f68bce3-e8cd-4db1-96e7-fbcaf984b709",
	"386":   "44479540-f297-41b2-9af7-d131d5f0458a",
	"arm":   "69dad710-2ce4-4e3c-b16c-21a1d49abed3",
	"arm64": "b921b045-1df0-41c3-af44-4c6f280d3fae",
	//"itanium": "993d8d3d-f80e-4225-855a-9daf8ed7ea97",
}

func (d *deviceRef) autodetectRoot(devPath string, t []gptPart) *deviceRef {
	rootTypeGuidRaw, ok := autodiscoveryRootGptTypes[runtime.GOARCH]
	if !ok {
		return d
	}
	rootTypeGuid, err := parseUUID(rootTypeGuidRaw)
	if err != nil {
		return d
	}

	debug("Scanning %s for the root partition. Used ESP was found in this device.", devPath)

	for _, p := range t {
		if bytes.Equal(rootTypeGuid, p.typeGUID) {
			// TODO: Honour GPT flags (read only & no auto)
			rootDevName := calculateDevName(devPath, p.num)
			debug("Found root partition: %s.", rootDevName)
			info, err := readBlkInfo(rootDevName)
			if err != nil {
				debug("The found root partition has an incompatible file system or isn't formatted. Searching for other partitions...")
				continue
			}
			if info.format == "luks" {
				debug("The found root partition has a LUKS header.")
				name, err := parseLuksParameters(info)
				if err != nil {
					debug("LUKS kernel parameters aren't valid. Substituting them with autogenerated parameters to unlock the found root partition in /dev/mapper/root.")
					cmdline["rd.luks.name"] = info.uuid.toString() + "=root"
					return &deviceRef{refName, "/dev/mapper/root"}
				} else if name != "" {
					debug("LUKS kernel parameters already specified. Unlocked root is expected on /dev/mapper/%s.", name)
					return &deviceRef{refName, "/dev/mapper/" + name}
				} else {
					_, nameSet := cmdline["rd.luks.name"]
					_, uuidSet := cmdline["rd.luks.uuid"]
					if nameSet || uuidSet {
						debug("Found root partition and LUKS kernel parameters don't match. Searching for other partitions...", rootDevName) // This edge case isn't handled in the specification. This should provide the most compatible behaviour.
						continue
					} else {
						debug("No LUKS kernel parameters were provided. Generating parameters to unlock the found root partition in /dev/mapper/root.")
						cmdline["rd.luks.name"] = info.uuid.toString() + "=root"
						return &deviceRef{refName, "/dev/mapper/root"}
					}
				}
			} else if info.isFs && info.format != "lvm" && info.format != "mdraid" {
				debug("The found root partition has a regular (not encrypted) filesystem. Using %s as root.", rootDevName)
				return &deviceRef{refName, rootDevName}
			} else if info.isFs {
				debug("The found root partition has an LVM physical volume or an mdraid block device. Those are incompatible with autodiscovery. Searching for other partitions...")
			}
		}
	}
	debug("No suitable root partitions were found on %s.", devPath) // We don't fail yet as this point may be reached in the unlikely but still valid situation of two ESPs with the same GUID.
	return d
}

func parseDeviceRef(name, param string, enableAutodetect bool) (*deviceRef, error) {
	if param == "" {
		// try to auto-discover gpt partition https://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec/
		if enableAutodetect && efiVarsAvailable {
			debug("%s= param is not specified. Use GPT partition autodiscovery.", name)

			_, data, err := attributes.ReadEfivarsWithGuid("LoaderDevicePartUUID", *util.StringToGUID("4a67b082-0a4c-41cf-b6c7-440b29bb8c4f"))
			if err != nil {
				return nil, err
			}

			espUuid := fromUnicode16(data.Bytes(), binary.LittleEndian)
			if err != nil {
				return nil, err
			}

			return &deviceRef{refEspUUID, espUuid}, nil
		}
		return nil, fmt.Errorf("%s= boot option is not specified", name)
	}

	if strings.HasPrefix(param, "UUID=") {
		uuid := strings.TrimPrefix(param, "UUID=")

		u, err := parseUUID(stripQuotes(uuid))
		if err != nil {
			return nil, fmt.Errorf("unable to parse UUID parameter %s: %v", param, err)
		}
		return &deviceRef{refFsUUID, u}, nil

	}
	if strings.HasPrefix(param, "/dev/disk/by-uuid/") {
		uuid := strings.TrimPrefix(param, "/dev/disk/by-uuid/")
		u, err := parseUUID(stripQuotes(uuid))
		if err != nil {
			return nil, fmt.Errorf("unable to parse UUID parameter %s: %v", param, err)
		}
		return &deviceRef{refFsUUID, u}, nil
	}
	if strings.HasPrefix(param, "LABEL=") {
		label := strings.TrimPrefix(param, "LABEL=")
		return &deviceRef{refFsLabel, label}, nil
	}
	if strings.HasPrefix(param, "/dev/disk/by-label/") {
		label := strings.TrimPrefix(param, "/dev/disk/by-label/")
		return &deviceRef{refFsLabel, label}, nil
	}

	if strings.HasPrefix(param, "PARTUUID=") {
		uuid := strings.TrimPrefix(param, "PARTUUID=")

		if idx := strings.Index(uuid, "/PARTNROFF="); idx != -1 {
			param := uuid[idx+11:]
			uuid = uuid[:idx]
			partnoff, err := strconv.Atoi(param)
			if err != nil {
				return nil, fmt.Errorf("unable to parse PARTNROFF= value %s", param)
			}
			u, err := parseUUID(stripQuotes(uuid))
			if err != nil {
				return nil, fmt.Errorf("unable to parse UUID parameter %s: %v", param, err)
			}
			return &deviceRef{refGptUUIDPartoff, gptPartoffData{u, partnoff}}, nil
		} else {
			u, err := parseUUID(stripQuotes(uuid))
			if err != nil {
				return nil, fmt.Errorf("unable to parse UUID parameter %s: %v", param, err)
			}
			return &deviceRef{refGptUUID, u}, nil
		}
	}
	if strings.HasPrefix(param, "/dev/disk/by-partuuid/") {
		uuid := strings.TrimPrefix(param, "/dev/disk/by-partuuid/")
		u, err := parseUUID(stripQuotes(uuid))
		if err != nil {
			return nil, fmt.Errorf("unable to parse UUID parameter %s: %v", param, err)
		}
		return &deviceRef{refGptUUID, u}, nil
	}
	if strings.HasPrefix(param, "PARTLABEL=") {
		label := strings.TrimPrefix(param, "PARTLABEL=")
		return &deviceRef{refGptLabel, label}, nil
	}
	if strings.HasPrefix(param, "/dev/disk/by-partlabel/") {
		label := strings.TrimPrefix(param, "/dev/disk/by-partlabel/")
		return &deviceRef{refGptLabel, label}, nil
	}

	if strings.HasPrefix(param, "/dev/") {
		return &deviceRef{refName, param}, nil
	}

	return nil, fmt.Errorf("unable to parse %s= parameter '%s'", name, param)
}
